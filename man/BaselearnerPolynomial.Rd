% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{BaselearnerPolynomial}
\alias{BaselearnerPolynomial}
\title{Polynomial base learner}
\format{
\link{S4} object.
}
\arguments{
\item{data_source}{(\link{InMemoryData}) \cr
Data object which contains the raw data (see \code{?InMemoryData}).}

\item{blearner_type}{(\code{character(1)}) \cr
Type of the base learner (if not specified, \code{blearner_type = paste0("poly", d)} is used).
The unique id of the base learner is defined by appending \code{blearner_type} to
the feature name: \code{paste0(data_source$getIdentifier(), "_", blearner_type)}}

\item{degree}{(\code{integer(1)})\cr
Polynomial degree.}

\item{intercept}{(\code{logical(1)})\cr
Polynomial degree.}

\item{bin_root}{(\code{integer(1)})\cr
The binning root to reduce the data to \eqn{n^{1/\text{bin_root}}}$ data points
(default \code{bin_root = 1}, which means no binning is applied).
A value of \code{bin_root = 2} is suggested for the best approximation
error (cf. \emph{Wood et al. (2017) Generalized additive models for gigadata:
modeling the UK black smoke network daily data}).}
}
\description{
\verb{[BaselearnerPolynomial]} creates a polynomial base learner object.
The base learner takes one feature and calculates the polynomials (with
intercept) \eqn{1 + x + x^2 + \dots + x^d} for a given degree \eqn{d}.
}
\section{Usage}{

\preformatted{
BaselearnerPolynomial$new(data_source, list(degree, intercept, bin_root))
BaselearnerPolynomial$new(data_source, blearner_type, list(degree, intercept, bin_root))
}
}

\section{Fields}{

This class doesn't contain public fields.
}

\section{Methods}{

\itemize{
\item \verb{$summarizeFactory()}: \verb{() -> ()}
\item \verb{$transfromData(newdata)}: \code{list(InMemoryData) -> matrix()}
\item \verb{$getMeta()}: \verb{() -> list()}
}
}

\section{Inherited methods from Baselearner}{

\itemize{
\item \verb{$getData()}: \verb{() -> matrix()}
\item \verb{$getDF()}: \verb{() -> integer()}
\item \verb{$getPenalty()}: \verb{() -> numeric()}
\item \verb{$getPenaltyMat()}: \verb{() -> matrix()}
\item \verb{$getFeatureName()}: \verb{() -> character()}
\item \verb{$getModelName()}: \verb{() -> character()}
}
}

\examples{
# Sample data:
x = runif(100)
y = 1 + 2*x + rnorm(100, 0, 0.2)
dat = data.frame(x, y)

# S4 wrapper

# Create new data object, a matrix is required as input:
data_mat = cbind(x)
data_source = InMemoryData$new(data_mat, "my_data_name")

# Create new linear base learner factory:
bl_lin = BaselearnerPolynomial$new(data_source,
  list(degree = 1))
bl_cub = BaselearnerPolynomial$new(data_source,
  list(intercept = FALSE, degree = 3, bin_root = 2))

# Get the transformed data:
head(bl_lin$getData())
head(bl_cub$getData())

# Summarize factory:
bl_lin$summarizeFactory()

# Transform "new data":
newdata = list(InMemoryData$new(cbind(rnorm(5)), "my_data_name"))
bl_lin$transformData(newdata)
bl_cub$transformData(newdata)

# R6 wrapper

cboost_lin = Compboost$new(dat, "y")
cboost_lin$addBaselearner("x", "lin", BaselearnerPolynomial, degree = 1)
cboost_lin$train(100, 0)

cboost_cub = Compboost$new(dat, "y")
cboost_cub$addBaselearner("x", "cubic", BaselearnerPolynomial, intercept = FALSE, degree = 3, bin_root = 2)
cboost_cub$train(100, 0)

# Access base learner directly from the API (n = sqrt(100) = 10 with binning):
head(cboost_lin$baselearner_list$x_lin$factory$getData())
cboost_cub$baselearner_list$x_cubic$factory$getData()

gg_lin = plotPEUni(cboost_lin, "x")
gg_cub = plotPEUni(cboost_cub, "x")

library(ggplot2)
library(patchwork)

(gg_lin | gg_cub) &
  geom_point(data = dat, aes(x = x, y = y - c(cboost_lin$offset)), alpha = 0.2)
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{LossCustom}
\alias{LossCustom}
\title{Create LossCustom by using R functions.}
\format{
\link{S4} object.
}
\arguments{
\item{lossFun}{(\code{function})\cr
\code{R} function to calculate the loss.}

\item{gradientFun}{(\code{function})\cr
\code{R} function to calculate the gradient.}

\item{initFun}{(\code{function})\cr
\code{R} function to calculate the constant initialization.}
}
\description{
\code{LossCustom} creates a custom loss by using
\code{Rcpp::Function} to set \code{R} functions.
}
\section{Usage}{

\preformatted{
LossCustom$new(lossFun, gradientFun, initFun)
}
}

\section{Inherited methods from Loss}{

\itemize{
\item \verb{$loss()}: \verb{matrix(), matrix() -> matrix()}
\item \verb{$gradient()}: \verb{matrix(), matrix() -> matrix()}
\item \verb{$constInit()}: \code{matrix() -> matrix()}
\item \verb{$calculatePseudoResiduals()}: \verb{matrix(), matrix() -> matrix()}
\item \verb{$getLossType()}: \verb{() -> character(1)}
}
}

\section{Details}{

The functions must have the following structure:

\code{lossFun(truth, prediction) { ... return (loss) }} With a vector
argument \code{truth} containing the real values and a vector of
predictions \code{prediction}. The function must return a vector
containing the loss for each component.

\code{gradientFun(truth, prediction) { ... return (grad) }} With a vector
argument \code{truth} containing the real values and a vector of
predictions \code{prediction}. The function must return a vector
containing the gradient of the loss for each component.

\code{initFun(truth) { ... return (init) }} With a vector
argument \code{truth} containing the real values. The function must
return a numeric value containing the offset for the constant
initialization.
}

\examples{

# Loss function:
myLoss = function (true_values, prediction) {
  return (0.5 * (true_values - prediction)^2)
}
# Gradient of loss function:
myGradient = function (true_values, prediction) {
  return (prediction - true_values)
}
# Constant initialization:
myConstInit = function (true_values) {
  return (mean(true_values))
}

# Create new custom quadratic loss:
my_loss = LossCustom$new(myLoss, myGradient, myConstInit)

}

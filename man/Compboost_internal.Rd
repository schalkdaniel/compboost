% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{Compboost_internal}
\alias{Compboost_internal}
\title{Internal Compboost Class}
\format{
\link{S4} object.
}
\arguments{
\item{oob_response}{(\link{ResponseRegr} | \link{ResponseBinaryClassif})\cr
The response object containing the target variable.}

\item{learning_rate}{(\code{numeric(1)})\cr
The learning rate.}

\item{stop_if_all_stopper_fulfilled}{(\code{logical(1)})\cr
Boolean to indicate which stopping strategy is used. If \code{TRUE},
the algorithm stops if the conditions of all loggers for stopping apply.}

\item{factory_list}{(\link{BlearnerFactoryList})\cr
List of base learner factories from which one base learner is selected
in each iteration by using the}

\item{loss}{(\link{LossQuadratic} | \link{LossBinomial} | \link{LossHuber} | \link{LossAbsolute} | \link{LossQuantile})\cr
An initialized \code{S4} loss object (requires to call \verb{Loss*$new(...)}).
See the respective help page for further information.}

\item{logger_list}{(\link{LoggerList})\cr
The \link{LoggerList} object with all loggers.}

\item{optimizer}{(\link{OptimizerCoordinateDescent} | \link{OptimizerCoordinateDescentLineSearch} | \link{OptimizerAGBM} | \link{OptimizerCosineAnnealing})\cr
An initialized \code{S4} optimizer object (requires to call \code{Optimizer*.new(..)}.
See the respective help page for further information.}
}
\description{
This class is the raw \verb{C++} pendant and still at a very high-level.
It is the base for the \link{Compboost} \link{R6} class and provides
many convenient wrapper to access data and execute methods by calling
the \verb{C++} methods.
}
\section{Usage}{

\preformatted{
Compboost$new(response, learning_rate, stop_if_all_stopper_fulfilled,
  factory_list, loss, logger_list, optimizer)
}
}

\section{Fields}{

This class doesn't contain public fields.
}

\section{Methods}{

\itemize{
\item \verb{$train()}: \verb{() -> ()}
\item \verb{$continueTraining()}: \verb{() -> ()}
\item \verb{$getLearningRate()}: \verb{() -> numeric(1)}
\item \verb{$getPrediction()}: \verb{() -> matrix()}
\item \verb{$getSelectedBaselearner()}: \verb{() -> character()}
\item \verb{$getLoggerData()}: \verb{() -> list(character(), matrix())}
\item \verb{$getEstimatedParameter()}: \verb{() -> list(matrix())}
\item \verb{$getParameterAtIteration()}: \verb{() -> list(matrix())}
\item \verb{$getParameterMatrix()}: \verb{() -> matrix()}
\item \verb{$predictFactoryTrainData()}: \verb{() -> matrix()}
\item \verb{$predictFactoryNewData()}: \verb{list(Data*) -> matrix()}
\item \verb{$predictIndividualTrainData()}: \verb{() -> list(matrix())} Get the linear contribution of each base learner for the training data.
\item \verb{$predictIndividual()}: \verb{list(Data*) -> list(matrix())} Get the linear contribution of each base learner for new data.
\item \verb{$predict()}: \verb{list(Data*), logical(1) -> matrix()}
\item \verb{$summarizeCompboost()}: \verb{() -> ()}
\item \verb{$isTrained()}: \verb{() -> logical(1)}
\item \verb{$setToIteration()}: \verb{() -> ()}
\item \verb{$saveJson()}: \verb{() -> ()}
\item \verb{$getOffset()}: \verb{() -> numeric(1) | matrix()}
\item \verb{$getRiskVector()}: \verb{() -> numeric()}
\item \verb{$getResponse()}: \verb{() -> Response*}
\item \verb{$getOptimizer()}: \verb{() -> Optimizer*}
\item \verb{$getLoss()}: \verb{() -> Loss*}
\item \verb{$getLoggerList()}: \verb{() -> LoggerList}
\item \verb{$getBaselearnerList()}: \verb{() -> BlearnerFactoryList}
\item \verb{$useGlobalStopping()}: \verb{() -> logical(1)*}
\item \verb{$getFactoryMap()}: \verb{() -> list(Baselearner*)}
\item \verb{$getDataMap()}: \verb{() -> list(Data*)}
}
}

\examples{

# Some data:
df = mtcars
df$mpg_cat = ifelse(df$mpg > 20, "high", "low")

# # Create new variable to check the polynomial base learner with degree 2:
# df$hp2 = df[["hp"]]^2

# Data for the baselearner are matrices:
X_hp = as.matrix(df[["hp"]])
X_wt = as.matrix(df[["wt"]])

# Target variable:
response = ResponseBinaryClassif$new("mpg_cat", "high", df[["mpg_cat"]])

data_source_hp = InMemoryData$new(X_hp, "hp")
data_source_wt = InMemoryData$new(X_wt, "wt")

# List for oob logging:
oob_data = list(data_source_hp, data_source_wt)

# List to test prediction on newdata:
test_data = oob_data

# Factories:
linear_factory_hp = BaselearnerPolynomial$new(data_source_hp,
  list(degree = 1, intercept = TRUE))
linear_factory_wt = BaselearnerPolynomial$new(data_source_wt,
  list(degree = 1, intercept = TRUE))
quadratic_factory_hp = BaselearnerPolynomial$new(data_source_hp,
  list(degree = 2, intercept = TRUE))
spline_factory_wt = BaselearnerPSpline$new(data_source_wt,
  list(degree = 3, n_knots = 10, penalty = 2, differences = 2))

# Create new factory list:
factory_list = BlearnerFactoryList$new()

# Register factories:
factory_list$registerFactory(linear_factory_hp)
factory_list$registerFactory(linear_factory_wt)
factory_list$registerFactory(quadratic_factory_hp)
factory_list$registerFactory(spline_factory_wt)

# Define loss:
loss_bin = LossBinomial$new()

# Define optimizer:
optimizer = OptimizerCoordinateDescent$new()

## Logger

# Define logger. We want just the iterations as stopper but also track the
# time, inbag risk and oob risk:
log_iterations  = LoggerIteration$new(" iteration_logger", TRUE, 500)
log_time        = LoggerTime$new("time_logger", FALSE, 500, "microseconds")

# Define new logger list:
logger_list = LoggerList$new()

# Register the logger:
logger_list$registerLogger(log_iterations)
logger_list$registerLogger(log_time)

# Run compboost:
# --------------

# Initialize object:
cboost = Compboost_internal$new(
  response      = response,
  learning_rate = 0.05,
  stop_if_all_stopper_fulfilled = FALSE,
  factory_list = factory_list,
  loss         = loss_bin,
  logger_list  = logger_list,
  optimizer    = optimizer
)

# Train the model (we want to print the trace):
cboost$train(trace = 50)
cboost

# Get estimated parameter:
cboost$getEstimatedParameter()

# Get trace of selected base learner:
cboost$getSelectedBaselearner()

# Set to iteration 200:
cboost$setToIteration(200, 30)

# Get new parameter values:
cboost$getEstimatedParameter()

}

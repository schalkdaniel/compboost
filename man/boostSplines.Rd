% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/boost_splines.R
\name{boostSplines}
\alias{boostSplines}
\title{Wrapper to boost general additive models for each feature.}
\usage{
boostSplines(
  data,
  target,
  optimizer = NULL,
  loss = NULL,
  learning_rate = 0.05,
  iterations = 100,
  trace = -1,
  degree = 3,
  n_knots = 20,
  penalty = 2,
  df = 0,
  differences = 2,
  data_source = InMemoryData,
  oob_fraction = NULL,
  bin_root = 0,
  cache_type = "inverse",
  stop_args = list(),
  df_cat = 1,
  stop_time = "microseconds",
  additional_risk_logs = list()
)
}
\arguments{
\item{data}{\link{\code{data.frame}}\cr
A data frame containing the data.}

\item{target}{\link{\code{character(1)} or \code{Response} class}\cr
Character value containing the target variable or Response object. Note that the loss must match the
data type of the target.}

\item{optimizer}{\link{\code{S4 Optimizer}}\cr
An initialized \code{S4 Optimizer} object exposed by Rcpp (e.g. \code{OptimizerCoordinateDescent$new()})
to select features at each iteration.}

\item{loss}{\link{\code{S4 Loss}}\cr
Initialized \code{S4 Loss} object exposed by Rcpp that is used to calculate the risk and pseudo
residuals (e.g. \code{LossQuadratic$new()}).}

\item{learning_rate}{\link{\code{numeric(1)}}\cr
Learning rate to shrink the parameter in each step.}

\item{iterations}{\link{\code{integer(1)}}\cr
Number of iterations that are trained. If \code{iterations == 0}, the untrained object is returned. This
can be useful if other base learners (e.g. an interaction via a tensor base learner) are added.}

\item{trace}{\link{\code{integer(1)}}\cr
Integer indicating how often a trace should be printed. Specifying \code{trace = 10}, then every
10th iteration is printed. If no trace should be printed set \code{trace = 0}. Default is
-1 which means that in total 40 iterations are printed.}

\item{degree}{\link{\code{integer(1)}}\cr
Polynomial degree of the splines.}

\item{n_knots}{\link{\code{integer(1)}}\cr
Number of equidistant "inner knots". The actual number of used knots does also depend on
the polynomial degree.}

\item{penalty}{\link{\code{numeric(1)}}\cr
Penalty term for p-splines. If the penalty equals 0, then ordinary b-splines are fitted.
The higher the penalty, the higher the smoothness.}

\item{df}{\link{\code{numeric(1)}}\cr
Degrees of freedom of the whole spline. It is important to set the same amount of degrees of freedom to be able to compare different base-learner.}

\item{differences}{\link{\code{integer(1)}}\cr
Number of differences that are used for penalization. The higher the difference, the higher the smoothness.}

\item{data_source}{\link{\code{S4 Data}}\cr
Uninitialized \code{S4 Data} object which is used to store the data. At the moment
just in memory training is supported.}

\item{oob_fraction}{\link{\code{numeric(1)}}\cr
Fraction of how much data we want to use to track the out of bag risk.}

\item{bin_root}{\link{\code{integer(1)}}\cr
If set to a value greater than zero, binning is applied and reduces the number of used
x values to n^(1/bin_root) equidistant points. If you want to use binning we suggest
to set \code{bin_root = 2}.}

\item{cache_type}{\link{\code{character(1)}+}\cr
String to indicate what method should be used to estimate the parameter in each iteration.
Default is \code{cache_type = "cholesky"} which computes the Cholesky decomposition,
caches it, and reuses the matrix over and over again. The other option is to use
\code{cache_type = "inverse"} which does the same but caches the inverse.}

\item{stop_args}{\link{\code{list(2)}}\cr
List containing two elements \code{patience} and \code{eps_for_break} which can be set to use early stopping on the left out data
from setting \code{oob_fraction}.}

\item{df_cat}{\link{\code{numeric(1)}}\cr
Degrees of freedom of the categorical base-learner.}

\item{stop_time}{\link{\code{character(1)}}\cr
Unit of measured time.}

\item{additional_risk_logs}{\link{\code{list(Logger)}}\cr
Additional logger passed to the \code{Compboost} object.}
}
\value{
A model of the \code{Compboost} class. This model is an \code{R6} object
which can be used for retraining, predicting, plotting, and anything described in
\code{?Compboost}.
}
\description{
This wrapper function automatically initializes the model by adding all numerical
features as spline base-learner. Categorical features are dummy encoded and inserted
using another linear base-learners without intercept. The function \code{boostSplines}
does also train the model.
}
\details{
The returned object is an object of the \code{Compboost} class. This object can be
used for further analyses (see \code{?Compboost} for details).
}
\examples{
mod = boostSplines(data = iris, target = "Sepal.Length", loss = LossQuadratic$new(),
  oob_fraction = 0.3)
mod$getBaselearnerNames()
mod$getEstimatedCoef()
table(mod$getSelectedBaselearner())
mod$predict()
}

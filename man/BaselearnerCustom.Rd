% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{BaselearnerCustom}
\alias{BaselearnerCustom}
\title{Custom base learner using \code{R} functions.}
\format{
\link{S4} object.
}
\arguments{
\item{data_source}{(\link{InMemoryData})\cr
Uninitialized data object used to store the meta data. Note: At the moment, just in memory
storing is supported, see \code{?InMemorydata} for details.}

\item{instantiate_fun}{(\code{function})\cr
\code{R} function to transform the source data.}

\item{train_fun}{(\code{function})\cr
\code{R} function to train the base learner on the target data.}

\item{predict_fun}{(\code{function})\cr
\code{R} function to predict on the object returned by \code{train_fun}.}

\item{param_fun}{(\code{function})\cr
\code{R} function to extract the parameter of the object returned by \code{train}.}
}
\description{
This class defines a custom base learner factory by
passing \code{R} functions for instantiation, fitting, and predicting.
}
\section{Usage}{

\preformatted{
BaselearnerCustom$new(data_source, list(instantiate_fun,
  train_fun, predict_fun, param_fun))
}
}

\section{Details}{

The function must have the following structure:

\code{instantiateData(X) { ... return (X_trafo) }} With a matrix argument
\code{X} and a matrix as return object.

\code{train(y, X) { ... return (SEXP) }} With a vector argument \code{y}
and a matrix argument \code{X}. The target data is used in \code{X} while
\code{y} contains the response. The function can return any \code{R}
object which is stored within a \code{SEXP}.

\code{predict(model, newdata) { ... return (prediction) }} The returned
object of the \code{train} function is passed to the \code{model}
argument while \code{newdata} contains a new matrix used for predicting.

\code{extractParameter() { ... return (parameters) }} Again, \code{model}
contains the object returned by \code{train}. The returned object must be
a matrix containing the estimated parameter. If no parameter should be
estimated one can return \code{NA}.

For an example see the \code{Examples}.
}

\section{Fields}{

This class doesn't contain public fields.
}

\section{Methods}{

\itemize{
\item \verb{$summarizeFactory()}: \verb{() -> ()}
\item \verb{$transfromData(newdata)}: \code{list(InMemoryData) -> matrix()}
\item \verb{$getMeta()}: \verb{() -> list()}
}
}

\section{Inherited methods from Baselearner}{

\itemize{
\item \verb{$getData()}: \verb{() -> matrix()}
\item \verb{$getDF()}: \verb{() -> integer()}
\item \verb{$getPenalty()}: \verb{() -> numeric()}
\item \verb{$getPenaltyMat()}: \verb{() -> matrix()}
\item \verb{$getFeatureName()}: \verb{() -> character()}
\item \verb{$getModelName()}: \verb{() -> character()}
\item \verb{$getBaselearnerId()}: \verb{() -> character()}
}
}

\examples{
# Sample data:
data_mat = cbind(1, 1:10)
y = 2 + 3 * 1:10

# Create new data object:
data_source = InMemoryData$new(data_mat, "my_data_name")

instantiateDataFun = function (X) {
  return(X)
}
# Ordinary least squares estimator:
trainFun = function (y, X) {
  return(solve(t(X) \%*\% X) \%*\% t(X) \%*\% y)
}
predictFun = function (model, newdata) {
  return(as.matrix(newdata \%*\% model))
}
extractParameter = function (model) {
  return(as.matrix(model))
}

# Create new custom linear base learner factory:
custom_lin_factory = BaselearnerCustom$new(data_source,
  list(instantiate_fun = instantiateDataFun, train_fun = trainFun,
    predict_fun = predictFun, param_fun = extractParameter))

# Get the transformed data:
custom_lin_factory$getData()

# Summarize factory:
custom_lin_factory$summarizeFactory()

}
